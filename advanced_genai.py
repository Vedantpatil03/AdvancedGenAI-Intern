# -*- coding: utf-8 -*-
"""Advanced GenAI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WvfdRhfZtL0chBx9Noh1dxEtf8HWwD9p
"""

import pandas as pd

orders = pd.read_csv("orders.csv")
print(orders.head())

users = pd.read_json("users.json")
print(users.head())

import sqlite3

conn = sqlite3.connect("restaurants.db")

with open("restaurants.sql", "r") as f:
    sql_script = f.read()

cursor = conn.cursor()
cursor.executescript(sql_script)
conn.commit()

restaurants = pd.read_sql_query("SELECT * FROM restaurants", conn)
print(restaurants.head())

orders_users = pd.merge(
    orders,
    users,
    on="user_id",
    how="left"
)

final_df = pd.merge(
    orders_users,
    restaurants,
    on="restaurant_id",
    how="left"
)

print(final_df.head())
print(final_df.shape)

final_df.to_csv("final_food_delivery_dataset.csv", index=False)

"""## Load Final Dataset

### Subtask:
Load the `final_food_delivery_dataset.csv` into a pandas DataFrame for analysis. This DataFrame contains all the merged information.

"""

final_df = pd.read_csv('final_food_delivery_dataset.csv')
print(final_df.head())

"""## Prepare Data for Analysis

### Subtask:
Convert the 'order_date' column to datetime objects to enable time-based analysis. Extract year, month, and day information as needed for trend analysis.

"""

final_df['order_date'] = pd.to_datetime(final_df['order_date'], format='%d-%m-%Y')

final_df['order_year'] = final_df['order_date'].dt.year
final_df['order_month'] = final_df['order_date'].dt.month
final_df['order_day'] = final_df['order_date'].dt.day

print(final_df.head())
print(final_df.info())

"""## Analyze Order Trends Over Time

### Subtask:
Calculate and visualize the number of orders over time (e.g., monthly, quarterly) to identify trends and patterns. Provide appropriate labels and a legend.

"""

import matplotlib.pyplot as plt
import seaborn as sns

# Group by order_month and count unique order_ids for monthly order count
monthly_orders = final_df.groupby('order_month')['order_id'].nunique().reset_index()
monthly_orders.columns = ['order_month', 'number_of_orders']

# Visualize the monthly order count
plt.figure(figsize=(10, 6))
sns.lineplot(x='order_month', y='number_of_orders', data=monthly_orders, marker='o')

# Add title and labels
plt.title('Monthly Order Trends')
plt.xlabel('Month')
plt.ylabel('Number of Orders')
plt.xticks(monthly_orders['order_month'])
plt.grid(True)
plt.tight_layout()
plt.show()

"""## Analyze User Behavior Patterns

### Subtask:
Investigate user behavior by analyzing metrics such as the number of orders per user, average spend per user, and identifying top users by order count or total spend. Visualize key findings.

**Reasoning**:
The subtask requires analyzing user behavior patterns by calculating metrics like orders per user, total spend per user, and average spend per order. I will group the `final_df` by `user_id` and compute these aggregates. I will then display the head of the resulting DataFrame to show the calculated metrics.
"""

user_behavior = final_df.groupby('user_id').agg(
    orders_per_user=('order_id', 'nunique'),
    total_spend_per_user=('total_amount', 'sum')
).reset_index()

user_behavior['avg_spend_per_order'] = user_behavior['total_spend_per_user'] / user_behavior['orders_per_user']

print("User behavior metrics:")
print(user_behavior.head())

plt.figure(figsize=(10, 6))
sns.histplot(user_behavior['orders_per_user'], bins=range(1, user_behavior['orders_per_user'].max() + 2), kde=False)
plt.title('Distribution of Orders Per User')
plt.xlabel('Number of Orders')
plt.ylabel('Number of Users')
plt.xticks(range(1, user_behavior['orders_per_user'].max() + 1, max(1, (user_behavior['orders_per_user'].max() // 10))))
plt.grid(axis='y', alpha=0.75)
plt.tight_layout()
plt.show()

"""**Reasoning**:
I will now create a histogram to visualize the distribution of 'total_spend_per_user' to understand how much users typically spend. This addresses the sixth instruction of the subtask.


"""

plt.figure(figsize=(10, 6))
sns.histplot(user_behavior['total_spend_per_user'], bins=20, kde=False)
plt.title('Distribution of Total Spend Per User')
plt.xlabel('Total Spend')
plt.ylabel('Number of Users')
plt.grid(axis='y', alpha=0.75)
plt.tight_layout()
plt.show()

"""**Reasoning**:
To identify the top 10 users by the number of orders, I will sort the `user_behavior` DataFrame by the 'orders_per_user' column in descending order and display the top 10 rows. This addresses the seventh instruction of the subtask.


"""

top_10_users_by_orders = user_behavior.sort_values(by='orders_per_user', ascending=False).head(10)
print("Top 10 users by number of orders:")
print(top_10_users_by_orders)

top_10_users_by_spend = user_behavior.sort_values(by='total_spend_per_user', ascending=False).head(10)
print("Top 10 users by total spend:")
print(top_10_users_by_spend)

"""## Analyze City-wise and Cuisine-wise Performance

### Subtask:
Group the data by 'city' and 'cuisine' to calculate total revenue and number of orders for each category. Visualize the top-performing cities and cuisines with appropriate labels and legends.

"""

city_performance = final_df.groupby('city').agg(
    total_revenue=('total_amount', 'sum'),
    number_of_orders=('order_id', 'count')
).reset_index()

print("City Performance:")
print(city_performance.head())

"""**Reasoning**:
Now that 'city_performance' is created, I will sort it by 'total_revenue' in descending order to identify the top performing cities as per the second instruction.


"""

top_5_cities_revenue = city_performance.sort_values(by='total_revenue', ascending=False).head(5)
print("Top 5 Cities by Total Revenue:")
print(top_5_cities_revenue)

plt.figure(figsize=(10, 6))
sns.barplot(x='city', y='total_revenue', data=top_5_cities_revenue)
plt.title('Top 5 Cities by Total Revenue')
plt.xlabel('City')
plt.ylabel('Total Revenue')
plt.grid(axis='y', alpha=0.75)
plt.tight_layout()
plt.show()

"""**Reasoning**:
I will now create a bar plot to visualize the number of orders by the top 5 cities, as requested by the fourth instruction. This will use the `top_5_cities_revenue` DataFrame and `seaborn`.


"""

plt.figure(figsize=(10, 6))
sns.barplot(x='city', y='number_of_orders', data=top_5_cities_revenue)
plt.title('Top 5 Cities by Number of Orders')
plt.xlabel('City')
plt.ylabel('Number of Orders')
plt.grid(axis='y', alpha=0.75)
plt.tight_layout()
plt.show()

"""**Reasoning**:
The next step is to group the `final_df` by the 'cuisine' column and aggregate the 'total_amount' for total revenue and 'order_id' for the count of orders, as specified in the fifth instruction. This will create the `cuisine_performance` DataFrame.


"""

cuisine_performance = final_df.groupby('cuisine').agg(
    total_revenue=('total_amount', 'sum'),
    number_of_orders=('order_id', 'count')
).reset_index()

print("Cuisine Performance:")
print(cuisine_performance.head())

top_5_cuisines_revenue = cuisine_performance.sort_values(by='total_revenue', ascending=False).head(5)
print("Top 5 Cuisines by Total Revenue:")
print(top_5_cuisines_revenue)

"""**Reasoning**:
I will create a bar plot to visualize the total revenue by the top 5 cuisines, as requested by the seventh instruction. This will use the `top_5_cuisines_revenue` DataFrame and `seaborn`.


"""

plt.figure(figsize=(10, 6))
sns.barplot(x='cuisine', y='total_revenue', data=top_5_cuisines_revenue)
plt.title('Top 5 Cuisines by Total Revenue')
plt.xlabel('Cuisine')
plt.ylabel('Total Revenue')
plt.grid(axis='y', alpha=0.75)
plt.tight_layout()
plt.show()

"""**Reasoning**:
I will now create a bar plot to visualize the number of orders by the top 5 cuisines, as requested by the eighth instruction. This will use the `top_5_cuisines_revenue` DataFrame and `seaborn`.

## Analyze Membership Impact (Gold vs Regular)

### Subtask:
Compare key metrics such as total revenue, average order value, and order frequency between 'Gold' and 'Regular' membership types. Visualize the differences with clear labels and a legend.

**Reasoning**:
I will start by grouping the `final_df` DataFrame by the 'membership' column and calculating the total revenue and number of orders for each membership type, as specified in the first instruction.
"""

membership_performance = final_df.groupby('membership').agg(
    total_revenue=('total_amount', 'sum'),
    number_of_orders=('order_id', 'count')
).reset_index()

print("Membership Performance:")
print(membership_performance)

"""**Reasoning**:
I will calculate the 'average_order_value' for each membership type by dividing the 'total_revenue' by the 'number_of_orders' in the `membership_performance` DataFrame, as specified in the second instruction.


"""

membership_performance['average_order_value'] = membership_performance['total_revenue'] / membership_performance['number_of_orders']

print("Membership Performance with Average Order Value:")
print(membership_performance.head())

"""**Reasoning**:
The previous output showed only the head of the `membership_performance` DataFrame. As per the third instruction, I need to print the entire `membership_performance` DataFrame to display all calculated metrics for both 'Gold' and 'Regular' memberships.


"""

print("Full Membership Performance:")
print(membership_performance)

"""**Reasoning**:
Now, I will create a bar plot to visualize the 'total_revenue' for 'Gold' vs. 'Regular' memberships, as specified in the fourth instruction. This will use the `membership_performance` DataFrame and `seaborn`.


"""

plt.figure(figsize=(8, 5))
sns.barplot(x='membership', y='total_revenue', data=membership_performance)
plt.title('Total Revenue by Membership Type')
plt.xlabel('Membership Type')
plt.ylabel('Total Revenue')
plt.grid(axis='y', alpha=0.75)
plt.tight_layout()
plt.show()

"""**Reasoning**:
I will now create a bar plot to visualize the 'number_of_orders' for 'Gold' vs. 'Regular' memberships, as specified in the fifth instruction. This will use the `membership_performance` DataFrame and `seaborn`.


"""

plt.figure(figsize=(8, 5))
sns.barplot(x='membership', y='number_of_orders', data=membership_performance)
plt.title('Number of Orders by Membership Type')
plt.xlabel('Membership Type')
plt.ylabel('Number of Orders')
plt.grid(axis='y', alpha=0.75)
plt.tight_layout()
plt.show()

plt.figure(figsize=(8, 5))
sns.barplot(x='membership', y='average_order_value', data=membership_performance)
plt.title('Average Order Value by Membership Type')
plt.xlabel('Membership Type')
plt.ylabel('Average Order Value')
plt.grid(axis='y', alpha=0.75)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 6))
sns.histplot(final_df['total_amount'], bins=30, kde=True)
plt.title('Distribution of Total Order Amount')
plt.xlabel('Total Amount')
plt.ylabel('Frequency')
plt.grid(axis='y', alpha=0.75)
plt.tight_layout()
plt.show()

"""**Reasoning**:
Now, I will calculate the total revenue per month by grouping the `final_df` by 'order_month' and summing the 'total_amount', as specified in the second instruction. This will create the `monthly_revenue` DataFrame.


"""

monthly_revenue = final_df.groupby('order_month')['total_amount'].sum().reset_index()
monthly_revenue.columns = ['order_month', 'total_revenue']

print("Monthly Revenue:")
print(monthly_revenue.head())

"""**Reasoning**:
I will create a line plot to visualize the `monthly_revenue`, as requested by the third instruction, with appropriate title and labels, and add markers and a grid for readability.


"""

plt.figure(figsize=(10, 6))
sns.lineplot(x='order_month', y='total_revenue', data=monthly_revenue, marker='o')
plt.title('Monthly Total Revenue Trend')
plt.xlabel('Month')
plt.ylabel('Total Revenue')
plt.xticks(monthly_revenue['order_month'])
plt.grid(True)
plt.tight_layout()
plt.show()